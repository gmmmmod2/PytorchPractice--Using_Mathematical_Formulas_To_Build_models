# Contributing to PytorchPractice

---

我们非常欢迎并希望您能对`PytorchPractice`做出贡献。在您开始提交您的贡献之前，本文将先介绍我们的开发与贡献流程：

## 贡献方式

---

我们欢迎不同的向`PytorchPractice`做出贡献的方式，如:

- 提交新的 Issue，如提出新加入的模型或者现存题目中有关模型的问题
- 修复已知的 Issue
- 创建新的题目并实现其中的模型结构

我们建议您在使用过该项目提供的题库后开始提交您的问题与想法。

## Markdown 格式

Markdown 文件中的内容，只包含当前题目的：实现目标(必须)，数学定义(必须)，额外的输入/输出定义，实现要求，参考实现(必须)。在参考实现部分，不提供演示案例。

## 难度定级方式

---

对于题目难度的定级，我们统一采取满足“多数条件”优先的方式，具体难度条件如下表格:
| 评分类目 | 简单（easy） | 中等（middling） | 困难（hard） |
| ---------- | ------------------------------ | -------------------------------------- | --------------------------------------- |
| 数学深度 | 直接照搬教材/论文中的已知公式（1–5 条均可）；无新组合、无符号重构；实现仅需按公式逐项写出。 | 存在公式间的组合、依赖或改写; 或需要区分输入输出维度变化。 | 涉及多模块联立/约束/正则项或非显式推导 |
| 功能面 | 单一部件（如一个 Cell/多个简单层/多种简单变换） | 小型组合（2–3 个部件串/并联）或带可选开关 | 子系统级（多部件+策略），含可插拔/多分支 |
| 形状与批处理 | 固定形状；`batch_first=True`；无 mask | 变长序列或 padding；需要 mask/broadcast | 同时支持变长、双向/多头/多层；动态步长 |
| 数值稳定性 | 基本操作；无需特别防护 | 需要 ε、clip、log-sum-exp 等常规稳定化 | 需系统性稳定设计（fp16 兼容、规范化顺序、残差尺度等） |
| 向量化与性能 | 允许少量 for-loop；小规模张量 | 主要向量化；避免显著 O(T·D) 级冗余 | 必须向量化；复杂注意力/大 T 仍需可跑且高效 |
| PyTorch 依赖 | 只用 `torch` 基础张量算子或极少量 `nn` | 合理使用 `nn`/`F` 常用 API，必要时自写 op | 自定义模块较多；需权衡 `autograd`、`register_*` 等 |
| 训练相关 | 只需 `forward`；不自定义反向 | 默认 autograd 足够；可能需要 `requires_grad` 细节 | 可能涉及自定义状态/缓存，影响梯度正确性（但不强制写自定义 backward） |
| 可配置性 | 1–2 个核心超参 | 3–5 个超参（如是否残差/归一化/投影维） | 多超参与模式（双向/多头/分组、混合精度兼容） |
| 可靠性验证 | 基本数值对拍：形状、简单等式 | 增加极值/边界（全零、极大/极小、短序列） | 系统回归：随机种子一致性、mask 复杂场景、梯度有限差分近似 |
| 代码体量（参考） | ≤ 60 行核心代码 | 60–150 行核心代码 | 150–300 行 |
