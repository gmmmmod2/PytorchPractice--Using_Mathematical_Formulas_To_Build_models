# 题目：实现门控循环单元 GRUCell(单步)

> 目标 根据公式实现**单步 GRU Cell 的前向**，要求：
>
> - 形状/广播与 PyTorch 一致；
> - 支持批次维度 $B$；
> - 不合并权重(分别使用三组 $W_* / U_* / b_*$)。

## 数学定义

给定当步输入 $x_t \in \mathbb{R}^{d_{in}}$，上一步隐藏态 $h_{t-1} \in \mathbb{R}^{d_h}$：

$$
z_t = \sigma(W_z x_t + U_z h_{t-1} + b_z),
$$

$$
r_t = \sigma(W_r x_t + U_r h_{t-1} + b_r),
$$

$$
\tilde{h}_t = \tanh\!\big(W_h x_t + U_h (r_t \odot h_{t-1}) + b_h\big),
$$

$$
h_t = (1 - z_t)\odot h_{t-1} + z_t \odot \tilde{h}_t.
$$

其中 $\sigma$ 为 sigmoid，$\odot$ 表示逐元素乘法。

## 额外的输入/输出规定

输入张量, $x_t$: $(B, d_{in})$, $h_{t-1}$: $(B, d_h)$

输出, $h_t$: $(B, d_h)$

参数形状, $W_*$: $(d_h, d_{in})$, $U_*$: $(d_h, d_h)$, $b_*$: $(d_h,)$

## 实现要求

- **数值稳定性**：直接使用 sigmoid 与 $\tanh$ 即可；
- **形状校验**：鼓励在实现里做断言或友好报错；
- **不得**把三个门的权重合并成一大矩阵(本题考察逐门实现)。

## 参考实现

```python
import torch
import torch.nn as nn

class GRUCellRaw(nn.Module):
    def __init__(self, input_size: int, hidden_size: int):
        super().__init__()
        self.input_size = input_size
        self.hidden_size = hidden_size

        # 独立注册三组门参数（与 nn.GRUCell 的拼接版等价，但本题要求逐门保留）
        self.W_z = nn.Parameter(torch.empty(hidden_size, input_size))
        self.U_z = nn.Parameter(torch.empty(hidden_size, hidden_size))
        self.b_z = nn.Parameter(torch.empty(hidden_size))

        self.W_r = nn.Parameter(torch.empty(hidden_size, input_size))
        self.U_r = nn.Parameter(torch.empty(hidden_size, hidden_size))
        self.b_r = nn.Parameter(torch.empty(hidden_size))

        self.W_h = nn.Parameter(torch.empty(hidden_size, input_size))
        self.U_h = nn.Parameter(torch.empty(hidden_size, hidden_size))
        self.b_h = nn.Parameter(torch.empty(hidden_size))

        self.reset_parameters()

    def reset_parameters(self):
        # 与常见实现一致：Kaiming/Orthogonal/Xavier 都可，这里用简洁均匀初始化
        for p in (self.W_z, self.W_r, self.W_h):
            nn.init.kaiming_uniform_(p, a=5**0.5)
        for p in (self.U_z, self.U_r, self.U_h):
            nn.init.orthogonal_(p)
        for p in (self.b_z, self.b_r, self.b_h):
            nn.init.zeros_(p)

    def forward(self, x_t: torch.Tensor, h_prev: torch.Tensor) -> torch.Tensor:
        """
        x_t:   (B, d_in)
        h_prev:(B, d_h)
        return:(B, d_h)
        """
        B, d_in = x_t.shape
        _, d_h = h_prev.shape
        assert d_in == self.input_size and d_h == self.hidden_size, \
            f"shape mismatch: got x={x_t.shape}, h={h_prev.shape}, " \
            f"expect (*,{self.input_size}) and (*,{self.hidden_size})"

        # 门计算（按题面原始公式）
        z_t = torch.sigmoid(x_t @ self.W_z.T + h_prev @ self.U_z.T + self.b_z)    # (B, d_h)
        r_t = torch.sigmoid(x_t @ self.W_r.T + h_prev @ self.U_r.T + self.b_r)    # (B, d_h)
        h_tilde = torch.tanh(
            x_t @ self.W_h.T + (r_t * h_prev) @ self.U_h.T + self.b_h
        )  # (B, d_h)

        # 状态更新
        h_t = (1.0 - z_t) * h_prev + z_t * h_tilde                                 # (B, d_h)
        return h_t
```
