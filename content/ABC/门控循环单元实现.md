# 题目：门控循环单元（GRU）Cell（按原始公式）

**目标**：实现单步 GRU Cell，并与 `nn.GRUCell` 对齐。

---

## 数学定义

对时间步 $t$：

$$
z_t=\sigma(W_z x_t + U_z h_{t-1} + b_z),\quad
r_t=\sigma(W_r x_t + U_r h_{t-1} + b_r)
$$

$$
\tilde{h}_t=\tanh(W_h x_t + U_h (r_t \odot h_{t-1}) + b_h)
$$

$$
h_t = (1 - z_t)\odot h_{t-1} + z_t \odot \tilde{h}_t
$$

---

## 实现要求

- 参数形状与 PyTorch 一致：`W_*: (hidden, input)`, `U_*: (hidden, hidden)`。
- 实现与 `nn.GRUCell` 数值比对（同步参数）。

---

## 参考实现

```python
import torch
import torch.nn as nn

class MyGRUCell(nn.Module):
    def __init__(self, input_size, hidden_size):
        super().__init__()
        self.W_z = nn.Linear(input_size, hidden_size, bias=True)
        self.W_r = nn.Linear(input_size, hidden_size, bias=True)
        self.W_h = nn.Linear(input_size, hidden_size, bias=True)
        self.U_z = nn.Linear(hidden_size, hidden_size, bias=False)
        self.U_r = nn.Linear(hidden_size, hidden_size, bias=False)
        self.U_h = nn.Linear(hidden_size, hidden_size, bias=False)

    def forward(self, x_t, h_prev):
        z = torch.sigmoid(self.W_z(x_t) + self.U_z(h_prev))
        r = torch.sigmoid(self.W_r(x_t) + self.U_r(h_prev))
        h_tilde = torch.tanh(self.W_h(x_t) + self.U_h(r * h_prev))
        h = (1 - z) * h_prev + z * h_tilde
        return h

# 与官方 GRUCell 对齐
inp, hid = 5, 7
x = torch.randn(4, inp)
h0= torch.randn(4, hid)
mine = MyGRUCell(inp, hid)
ref  = nn.GRUCell(inp, hid)

# 同步参数
with torch.no_grad():
    ref.weight_ih.copy_(torch.stack([mine.W_r.weight, mine.W_z.weight, mine.W_h.weight], dim=0).reshape_as(ref.weight_ih))
    ref.bias_ih.copy_(torch.stack([mine.W_r.bias, mine.W_z.bias, mine.W_h.bias], dim=0).reshape_as(ref.bias_ih))
    ref.weight_hh.copy_(torch.stack([mine.U_r.weight, mine.U_z.weight, mine.U_h.weight], dim=0).reshape_as(ref.weight_hh))
    ref.bias_hh.zero_()

h1_mine = mine(x, h0)
h1_ref  = ref(x, h0)
print(torch.allclose(h1_mine, h1_ref, atol=1e-5))
```
